Booléens ---------
-----------negation pour les booléens:
	
(neg (lambda a (ifte (lambda x ((: (lambda a B) (pi a B *)) x)) a false true)) (pi a B ((: (lambda a B) (pi a B *)) a)))
 


-----------implication pour les booléens:
POUR RESOUDRE UN DES BUG DE LA SAUVEGARDE FAIRE AVEC CET EXEMPLE
(IDEE SUR LE BUG : peut etre qu'il faut simplement réinitialiser la variable du compteur des def a chaque fois que on a sauvegarder un truc)

(impl (lambda a (lambda b (ifte (lambda x (((: (lambda a (lambda b B)) (pi a B (pi b B *))) x) b)) a (ifte (lambda x (((: (lambda a (lambda b B)) (pi a B (pi b B *))) true) x)) b true false) true))) (pi a B (pi b B (((: (lambda a (lambda b B)) (pi a B (pi b B *))) a) b))))
		       	 


----------ou exclusif 

(xor (lambda a (lambda b (ifte (lambda x (((: (lambda a (lambda b B)) (pi a B (pi b B *))) x) b)) a (ifte (lambda x (((: (lambda a (lambda b B)) (pi a B (pi b B *))) true) x)) b false true) (ifte (lambda x (((: (lambda a (lambda b B)) (pi a B (pi b B *))) false) x)) b true false)))) (pi a B (pi b B (((: (lambda a (lambda b B)) (pi a B (pi b B *))) a) b))))


---------ou 

(or (lambda a (lambda b (ifte (lambda x (((: (lambda a (lambda b B)) (pi a B (pi b B *))) x) b)) a true (ifte (lambda x (((: (lambda a (lambda b B)) (pi a B (pi b B *))) false) x)) b true false)))) (pi a B (pi b B (((: (lambda a (lambda b B)) (pi a B (pi b B *))) a) b))))

---------et

(and (lambda a (lambda b (ifte (lambda x (((: (lambda a (lambda b B)) (pi a B (pi b B *))) x) b)) a (ifte (lambda x (((: (lambda a (lambda b B)) (pi a B (pi b B *))) true) x)) b true false) false))) (pi a B (pi b B (((: (lambda a (lambda b B)) (pi a B (pi b B *))) a) b))))





-------------------------------------les entiers -----------
-------addition:

(plus (lambda m (lambda n (iter (lambda x (((: (lambda m (lambda n N)) (pi m N (pi n N *))) x) n)) m (lambda x1 (lambda x2 (succ x2))) n))) (pi m N (pi n N (((: (lambda m (lambda n N)) (pi m N (pi n N *))) m) n))))

------multiplication :

(mult (lambda m (lambda n (iter (lambda x (((: (lambda m (lambda n N)) (pi m N (pi n N *))) x) n)) m (lambda x1 (lambda x2 (((: (lambda m (lambda n (iter (lambda x (((: (lambda m (lambda n N)) (pi m N (pi n N *))) x) n)) m (lambda x1 (lambda x2 (succ x2))) n))) (pi m N (pi n N N))) x2) n))) zero))) (pi m N (pi n N (((: (lambda m (lambda n N)) (pi m N (pi n N *))) m) n))))

	    
plus petit stric et pas strict (tous les comparateurs)

----------Le prédécesseur 

(pred (lambda m (p0 (iter (lambda x (sig y N N)) m (lambda x1 (lambda x2 ((p1 x2) , (succ (p1 x2))))) (zero , zero)))) (pi m N N))

---------is zero

(iszero (lambda m (iter (lambda x ((: (lambda m B) (pi m N *)) x)) m (lambda x1 (lambda x2 false)) true)) (pi m N ((: (lambda m B) (pi m N *)) m)))


---------L'égalité entre deux entiers



---------La soustraction

(soustr (lambda m (lambda n (iter (lambda x (((: (lambda m (lambda n N)) (pi m N (pi n N *))) x) n)) m (lambda x1 (lambda x2 ((: (lambda m (p0 (iter (lambda x (sig y N N)) m (lambda x1 (lambda x2 ((p1 x2) , (succ (p1 x2))))) (zero , zero)))) (pi m N N)) x2))) n))) (pi m N (pi n N (((: (lambda m (lambda n N)) (pi m N (pi n N *))) m) n))))

-----l'exponentiel

!!!!!!!!!!!!!!!!! ici (exp 2 3) equivalent a 2 ^ 3!!!!!!!!!!!!

(exp (lambda e (lambda m (iter (lambda x (((: (lambda e (lambda m N)) (pi e N (pi m N *))) x) m)) e (lambda x1 (lambda x2 (((: (lambda m (lambda n (iter (lambda x (((: (lambda m (lambda n N)) (pi m N (pi n N *))) x) n)) m (lambda x1 (lambda x2 (((: (lambda m (lambda n (iter (lambda x (((: (lambda m (lambda n N)) (pi m N (pi n N *))) x) n)) m (lambda x1 (lambda x2 (succ x2))) n))) (pi m N (pi n N N))) x2) n))) zero))) (pi m N (pi n N N))) x2) m))) (succ zero)))) (pi e N (pi m N (((: (lambda e (lambda m N)) (pi e N (pi m N *))) e) m))))


------la parité 

factorielle 

le maximum et minimum de deux nombres 

fonction qui double le nombre

-------la division par 2 entière (euclidienne)




----------------------------Listes--------------- 

-------la taille 

(lengthbool (lambda l (fold (lambda x ((: (lambda l N) (pi l (liste B) *)) x)) B l (lambda e (lambda xs (lambda h (succ h)))) zero)) (pi l (liste B) ((: (lambda l N) (pi l (liste B) *)) l)))


la tete (prend deux arguments le deuxième pour renvoyer quelque chose)
la queue (comme le suite dans ocaml avec le pattern matching a :: suite)

-------------crée une liste de taille n avec que des x de type A

(initlistebool (lambda n (lambda e (iter (lambda x (((: (lambda n (lambda e (liste B))) (pi n N (pi e B *))) x) e)) n (lambda x1 (lambda x2 (cons e x2))) nil))) (pi n N (pi e B (((: (lambda n (lambda e (liste B))) (pi n N (pi e B *))) n) e))))

la concaténation de deux listes

inversion de liste

le dernier élément de la liste

le n-ième élément d'une liste

fonction avec un prédicat (booléens) et une liste qui retourne le premier élément qui 
retourne l'indice du premier élément qui retourne true au predicat

fonction de filtrage : qui prend un prédicat et qui crée une liste avec les éléments qui ont passés le predicat(true)

fonction qui compte le nombre d'éléments qui passent le prédicat 

Exist : fonction qui retourne vrai si au moins un élément de la liste vérifie
le prédicat

Pourtout : qui retourne vrai si et seulement si tous les éléments de la liste 
vérifient le prédicat

drop : prend un entier n et une liste et jette les n premiers éléments de la liste

take : retourne les n premiers éléments de la liste (si la liste moins de n alors il faut retourner toute la liste)

l'égalité sur les listes : deux listes plus un prédicat permettant de tester 
si les éléments de la liste sont égaux deux a deux selon le prédicat

fonction zip qui prend deux listes et qui construit une liste des pairs.

fonction unzip qui prend une liste de paire et qui retoune une pair de deux listes 

flatten : prend une liste de liste de a et retourne une liste de a en concaténant toutes les listes qui sont à l'intérieur

produit cartésien : retourne des pairs issus de deux liste (a1 * b1) (a1 * b2)......(ai * bn)

lire papier 







